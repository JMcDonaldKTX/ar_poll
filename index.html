<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Camera + Fixed PNG/USDZ Overlay</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
  body,html{margin:0;padding:0;overflow:hidden;background:#000;}
  #container{position:relative;width:100vw;height:100vh;}
  video,canvas{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}
  canvas{z-index:1;}
  #ui{position:absolute;top:0;left:0;width:100%;padding:12px;color:#fff;text-align:center;z-index:2;font-family:sans-serif;}
  #startBtn{
    margin-top:20px;padding:12px 24px;font-size:18px;
    background:#007AFF;color:#fff;border:none;border-radius:8px;
  }
</style>
</head>
<body>

<div id="container">
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="overlay"></canvas>
</div>

<div id="ui">
  <h2 id="question"></h2>
  <button id="startBtn">Start Camera & Load Characters</button>
  <p id="status" style="display:none;"></p>
</div>

<script>
/* --------------------------------------------------------------
   CONFIG – put your own assets here
   -------------------------------------------------------------- */
const poll = {
  question: "Pick your favourite character",
  options: [
    { name: "Mario",   src: "mario.png"   },   // PNG (transparent works)
    { name: "Link",    src: "link.png"    },
    { name: "Pikachu", src: "pikachu.png" }
  ]
};

/* --------------------------------------------------------------
   Global vars
   -------------------------------------------------------------- */
const video   = document.getElementById('cam');
const canvas  = document.getElementById('overlay');
const ctx     = canvas.getContext('2d');
const startBtn= document.getElementById('startBtn');
const status  = document.getElementById('status');
const questionEl = document.getElementById('question');

let assets = [];          // {img, x, y, w, h}
let anchorsSet = false;   // true after first frame → lock positions

/* --------------------------------------------------------------
   1. Load PNG images (USDZ not supported on canvas)
   -------------------------------------------------------------- */
function loadAssets() {
  return Promise.all(
    poll.options.map(opt => {
      return new Promise((resolve,reject)=> {
        const img = new Image();
        img.crossOrigin = 'anonymous';          // needed if files are on another domain
        img.onload = () => resolve({img, name:opt.name, src:opt.src});
        img.onerror = () => reject(new Error(`Failed to load ${opt.src}`));
        img.src = opt.src;
      });
    })
  );
}

/* --------------------------------------------------------------
   2. Start camera
   -------------------------------------------------------------- */
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment' },   // rear camera
      audio: false
    });
    video.srcObject = stream;
    video.play();
    return true;
  } catch (e) {
    status.textContent = 'Camera error: ' + e.message;
    status.style.display = 'block';
    return false;
  }
}

/* --------------------------------------------------------------
   3. Resize canvas to match video (preserves aspect)
   -------------------------------------------------------------- */
function resizeCanvas() {
  const {videoWidth, videoHeight} = video;
  if (!videoWidth) return;
  canvas.width  = videoWidth;
  canvas.height = videoHeight;
}

/* --------------------------------------------------------------
   4. Main render loop
   -------------------------------------------------------------- */
function render() {
  if (video.readyState < 2) { requestAnimationFrame(render); return; }

  // 1. draw camera frame
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // 2. first frame → set world anchors
  if (!anchorsSet) {
    const vw = canvas.width, vh = canvas.height;
    assets.forEach((a,i) => {
      const size = Math.min(vw*0.25, vh*0.35);   // 25 % of width, max 35 % height
      const x = (i * (vw/3)) + (vw/6) - size/2; // evenly spaced
      const y = vh*0.45 - size/2;              // middle vertically
      a.x = x; a.y = y; a.w = size; a.h = size;
    });
    anchorsSet = true;
  }

  // 3. draw anchored images
  assets.forEach(a => {
    ctx.drawImage(a.img, a.x, a.y, a.w, a.h);
  });

  requestAnimationFrame(render);
}

/* --------------------------------------------------------------
   5. Click → vote (simple alert, replace with fetch later)
   -------------------------------------------------------------- */
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  for (const a of assets) {
    if (x >= a.x && x <= a.x+a.w && y >= a.y && y <= a.y+a.h) {
      alert(`You voted for ${a.name}!`);
      // TODO: send vote to server
      break;
    }
  }
});

/* --------------------------------------------------------------
   6. UI – start everything
   -------------------------------------------------------------- */
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  questionEl.textContent = poll.question;

  const camOK = await startCamera();
  if (!camOK) return;

  // wait for first video frame
  video.addEventListener('loadedmetadata', () => {
    resizeCanvas();
    render();
  }, {once:true});

  try {
    const loaded = await loadAssets();
    assets = loaded;
    status.textContent = `${assets.length} characters loaded`;
    status.style.display = 'block';
    setTimeout(()=>status.style.display='none',2000);
  } catch (err) {
    status.textContent = err.message;
    status.style.display = 'block';
  }
});
</script>

</body>
</html>
