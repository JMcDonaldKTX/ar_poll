<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AR Poll - Tap to Place</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    * { margin:0; padding:0; }
    body, html { overflow:hidden; background:#000; font-family:sans-serif; }
    #container { position:relative; width:100vw; height:100vh; }
    video, canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    canvas { z-index:2; }
    #ui { position:absolute; top:0; left:0; width:100%; padding:15px; color:#fff; text-align:center; z-index:3; }
    button { padding:12px 24px; margin:5px; font-size:18px; background:#007AFF; color:#fff; border:none; border-radius:8px; }
    #status { color:#ff3b30; font-size:14px; margin-top:8px; }
  </style>
</head>
<body>

<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
</div>

<div id="ui">
  <h2>D&D Character Poll</h2>
  <button id="start">Start Camera</button>
  <button id="place" style="display:none">Tap Screen to Place Characters</button>
  <div id="status"></div>
</div>

<script>
/* ============================= CONFIG ============================= */
const characters = [
  { name: "Elara the Unarmed Monk",   src: "char1.mp4",   type: "video"},
  { name: "Thorne Ironblade, Swordmaster",    src: "char2.mp4",   type: "video"},
  { name: "Lirien Starwhisper, Wand Wielder", src: "char3.mp4",   type: "video"}
];

/* ============================= GLOBALS ============================= */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('start');
const placeBtn = document.getElementById('place');
const status = document.getElementById('status');

let stream;
let images = [];
let anchor = null;  // {x, y, alpha, beta}
let placed = false;

/* ============================= LOAD IMAGES ============================= */
async function loadImages() {
  return Promise.all(characters.map(ch => {
    return new Promise((res, rej) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => res({img, name: ch.name});
      img.onerror = () => rej(`Failed: ${ch.src}`);
      img.src = ch.src;
    });
  }));
}
  
/* ============================= LOAD VIDEOS ============================= */
async function loadVideos() {
  return Promise.all(characters.map(ch => {
    return new Promise((res, rej) => {
      if (ch.type !== 'video') return res(ch);
      const vid = document.createElement('video');
      vid.crossOrigin = 'anonymous';
      vid.muted = true;
      vid.playsInline = true;
      vid.loop = true;
      vid.autoplay = true;
      vid.src = ch.src;
      vid.load();
      vid.oncanplay = () => {
        vid.play().catch(() => {});
        res({ vid, name: ch.name });
      };
      vid.onerror = () => rej(`Failed: ${ch.src}`);
    });
  }));
}
  
/* ============================= START CAMERA ============================= */
async function startCamera() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment' },
      audio: false
    });
    video.srcObject = stream;
    video.play();
    return true;
  } catch (e) {
    status.textContent = 'Camera failed: ' + e.message;
    return false;
  }
}

/* ============================= RESIZE CANVAS ============================= */
function resize() {
  const {videoWidth: w, videoHeight: h} = video;
  if (!w || !h) return;
  canvas.width = w;
  canvas.height = h;
}

/* ============================= GYROSCOPE ============================= */
let alpha = 0, beta = 0;
window.addEventListener('deviceorientation', e => {
  if (e.alpha !== null) alpha = e.alpha;
  if (e.beta !== null)  beta = e.beta;
});

/* ============================= ANCHOR MATH ============================= */
function setAnchor(x, y) {
  anchor = { x, y, alpha, beta };
  placed = true;
  placeBtn.remove(); // Completely gone
  status.textContent = 'Characters anchored! Move phone.';
  setTimeout(() => status.textContent = '', 2000);
}

function getCurrentPos() {
  if (!anchor) return null;

  const dAlpha = alpha - anchor.alpha;
  const dBeta = beta - anchor.beta;

  // Convert degrees to screen pixels (approx FOV: 60° horizontal)
  const pixelsPerDeg = canvas.width / 60;
  const offsetX = dAlpha * pixelsPerDeg;
  const offsetY = dBeta * pixelsPerDeg;

  return {
    x: anchor.x + offsetX,
    y: anchor.y + offsetY
  };
}

/* ============================= RENDER LOOP ============================= */
function render() {
  if (video.readyState < 2) {
    requestAnimationFrame(render);
    return;
  }

  // Draw camera
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Draw anchored characters
  if (placed && anchor) {
    const pos = getCurrentPos();
    if (pos) {
      const size = Math.min(canvas.width * 0.2, canvas.height * 0.3);
      const spacing = size * 0.2;

      images.forEach((item, i) => {
        const x = pos.x + (i - 1) * (size + spacing) - size / 2;
        const y = pos.y - size / 2;
      
        if (item.vid) {
          // It's a video — draw current frame
          ctx.drawImage(item.vid, x, y, size, size);
        } else if (item.img) {
          // It's an image (fallback)
          ctx.drawImage(item.img, x, y, size, size);
        }
      
        // Label
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'center';
        ctx.strokeText(item.name, x + size/2, y + size + 25);
        ctx.fillText(item.name, x + size/2, y + size + 25);
      });
    }
  }

  requestAnimationFrame(render);
}

/* ============================= TAP TO PLACE ============================= */
canvas.addEventListener('click', e => {
  if (!placed && images.length > 0) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    setAnchor(x, y);
    return; // stops the voting logic when you place the images
  } else if (placed) {
    // Vote detection
    const pos = getCurrentPos();
    if (!pos) return;
    const size = Math.min(canvas.width * 0.2, canvas.height * 0.3);
    const spacing = size * 0.2;

    images.forEach((img, i) => {
      const x = pos.x + (i - 1) * (size + spacing) - size / 2;
      const y = pos.y - size / 2;
      if (e.clientX >= rect.left + x && e.clientX <= rect.left + x + size &&
          e.clientY >= rect.top + y && e.clientY <= rect.top + y + size) {
        alert(`Voted: ${img.name}`);
        // fetch('/vote', {method:'POST', body: JSON.stringify({vote: img.name})});
      }
    });
  }
});

/* ============================= START ============================= */
startBtn.onclick = async () => {
  startBtn.disabled = true;
  status.textContent = 'Starting camera...';

  const camOk = await startCamera();
  if (!camOk) return;

  video.addEventListener('loadedmetadata', () => {
    resize();
    render();
  }, {once: true});

  // Request motion permission on iOS
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().catch(() => {
      status.textContent = 'Motion permission denied';
    });
  }

  try {
    images = await loadVideos();
    status.textContent = 'Tap screen to place characters';
    placeBtn.style.display = 'inline-block';
  } catch (e) {
    status.textContent = e.message;
  }
};
</script>
<!-- ====== VOTE COUNTING EXTENSION (DO NOT TOUCH ABOVE) ====== -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<div id="vote-ui" style="position:absolute; bottom:20px; left:0; width:100%; text-align:center; color:white; z-index:3; display:none;">
  <div style="background:rgba(0,0,0,0.7); padding:10px; border-radius:12px; display:inline-block;">
    <div id="vote-counts" style="font-size:18px; margin:8px 0;"></div>
    <button id="reset-votes" style="background:#FF3B30; padding:8px 16px; font-size:14px; border:none; border-radius:8px;">Reset All Votes</button>
  </div>
</div>

<script>
// ====== YOUR FIREBASE CONFIG (PASTE FROM STEP 1) ======
const firebaseConfig = {
  databaseURL: "https://arpoll-default-rtdb.firebaseio.com/",
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const votesRef = db.ref('votes');

// ====== VOTE UI ELEMENTS ======
const voteUI = document.getElementById('vote-ui');
const voteCountsEl = document.getElementById('vote-counts');
const resetBtn = document.getElementById('reset-votes');

// ====== TRACK VOTES LOCALLY & SYNC ======
const voteCounts = { Mario: 0, Link: 0, Pikachu: 0 };

function updateVoteDisplay() {
  voteCountsEl.innerHTML = Object.entries(voteCounts)
    .map(([name, count]) => `<strong>${name}:</strong> ${count}`)
    .join(' &nbsp;&nbsp; ');
}

// Listen for remote changes
votesRef.on('value', (snapshot) => {
  const data = snapshot.val() || {};
  Object.keys(voteCounts).forEach(name => {
    voteCounts[name] = data[name] || 0;
  });
  updateVoteDisplay();
});

// ====== SEND VOTE (MODIFY ONLY THIS PART OF TAP) ======
function sendVote(name) {
  const current = voteCounts[name] || 0;
  votesRef.child(name).set(current + 1);
  alert(`You voted for ${name}!`);
}

// ====== RESET ALL VOTES ======
resetBtn.onclick = () => {
  if (confirm('Reset all votes?')) {
    votesRef.set({ Mario: 0, Link: 0, Pikachu: 0 });
  }
};

// ====== SHOW VOTE UI AFTER PLACEMENT ======
const originalSetAnchor = setAnchor;
setAnchor = function(x, y) {
  originalSetAnchor(x, y);
  voteUI.style.display = 'block';
  updateVoteDisplay();
  placeBtn.remove(); // Clean removal
};

/* ============================= UNIFIED TAP HANDLER ============================= */
canvas.addEventListener('click', function(e) {
      const rect = canvas.getBoundingClientRect();
      const tapX = e.clientX - rect.left;
      const tapY = e.clientY - rect.top;
    
      // === 1. PLACEMENT (only if not placed) ===
      if (!placed && images.length > 0) {
        setAnchor(tapX, tapY);
        return; // STOP HERE — NO VOTE
      }
    
      // === 2. VOTING (only if placed) ===
      if (placed && anchor) {
        const pos = getCurrentPos();
        if (!pos) return;
    
        const size = Math.min(canvas.width * 0.2, canvas.height * 0.3);
        const spacing = size * 0.2;
    
        images.forEach((item, i) => {
          const x = pos.x + (i - 1) * (size + spacing) - size / 2;
          const y = pos.y - size / 2;
    
          if (tapX >= x && tapX <= x + size && tapY >= y && tapY <= y + size) {
            sendVote(item.name);
          }
        });
      }
    });
  }
};
</script>
</body>
</html>







